# JQuery基本

---



## 1.原生JS与JQuery获取DOM对象

- 原生JS  

  ```javascript
  var domObj = document.getElementById('idname');
  ```

- JQuery  

  ```javascript
  var domObj = $('#id');
  ```

## 2.原生JS与JQuery对象转化

- JQuery ————> JS

  ```javascript
  var domObj = $('#id');
  // 实际上JQuery 获取的对象是一个dom对象集合(数组)
  // 所以 取出其中的目标就可以进行原生js的对象操作了
  domObj[0].addEventListener('click', function(){alert('!!')});
  // 这样也可以
  domObj.get(0);
  ```

- JS ————> JQuery 

  ```javascript
  var domObj = document.getElementById('idname');
  // 直接在dom对象上 套上$就可以转换
  $(domObj).text('!!!!');
  ```

## 3.JQuery选择器

- 首先JQuery可以使用所有的CSS选择器

  ```javascript
  var $obj = $('#app li .main')  // id为app的元素下的所有li标签下的所有class为main的标签
  ```

- JQuery也有自己的过滤选择器

  ```javascript
  var li = $('#app li:eq(1)');  // 选择id为app的元素下的第二个元素  注意序号是从0开始的
  // 其他过滤选择器如
  :odd 选择奇数
  :even 选择偶数
  :gt(index) 大于index的
  :lt(index) 小于index的
  ```

- 筛选选择器

  ```javascript
  $('A').childern('B')  // 相当于css中 A>B
  $('A').find('B')  // 相当于css中 A B
  $('#app').siblings()  // 返回id为app的元素的 所有前后兄弟
  $('#app').siblings('li') // 返回id为app的元素的 所有前后li标签兄弟
  $('A').next()  // A的上一个兄弟 next()同样可以指定兄弟是哪一种标签
  $('A').prev()  // A的下一个兄弟 prev()同样可以指定兄弟是哪一种标签
  ```

==注意==

> **注意不同对象不同的方法**
>
> ```javascript
> var $Obj = $('#id');
> var domObj = document.getElementById('idname');
> $obj.text('!!!');  // √ 这是一个jquery对象
> $obj[0].text('!!!'); // × 这是一个dom对象，不能用jquery的方法
> $obj[0].innerHTML('!!!!'); // √
> $obj.get(0).text('!!!'); // × 这是一个dom对象，不能用jquery的方法
> domObj.text('!!!'); // × 这是一个dom对象，不能用jquery的方法
> domObj.innerHTML('!!!'); // √
> ```
>
> 

## 4.JQuery操作样式

- 主要使用CSS()方法

  ```html
  <style>
      .css1 {
  		padding: 0;
  		margin: 0;
  	}
      .css2 {
          color: blue;
      }
  
  </style>
  
  <div class="css1" style="color: red;"></div>
  ```

  **操作style(内联)样式**

  ```javascript
  $('div').css('color')  // css方法第一个参数是属性 读取style的第一个值
  >>>rgb(255, 0, 0)
  $('div').css('color'， 'pink')  // css方法第二个参数是属性值
  >>>设置div的style为pink
  $('div').css({
      'color': 'pink',
      'font-size': '30px'
  })  // 还可以直接按照对象的方式传递 font-size可以写成fontsize
  ```

  **操作Class(外联)样式**

  ```javascript
  $('div').addClass('css2');  // 添加样式
  $('div').removeClass('css2');  // 删除样式
  $('div').hasClass('css2');  // 判断是否有这个样式
  $('div').toggleClass('css2');  // 切换样式
  // oggleClass()可以配合其他函数，比如，点击一下调用这句话
  // 产生的结果就是添加--->删除---->添加...如此往复切换css
  ```

  

  ==注意==

> css()方法**设置**和**读取**都只是读取的**style**的值，并不是操作了css 。要操作css必须使用操作class的一些方法。

> 操作内联样式是会被后来的样式所**覆盖**的  

## 5.JQuery属性操作

```javascript
$('div').attr(属性名)  // 获取属性值
$('div').attr({。。。})  // 多个属性设置属性值 和css一样
$('div').attr(属性名， 值)  // 设置属性值会覆盖
// 用prop()代替这个方法更好
```

## 6.JQuery节点操作

```javascript
$('div').append(元素)  // 向div的末尾添加元素 这里的元素可以是字符串，也可以是dom元素，也可以是jquery元素
$('div').prepend(元素)  // 向div的头部添加元素
$('<p></p>').appendTo('div')  // 向div尾部增加一个p标签
$('div').after(元素)  // 向div后面增加一个元素
$('div').before(元素)  // 向div前面增加一个元素
$('div').empty()  // 清空div中的所有元素  通常使用.innerHTML = ''; 容易产生内存泄露
$('div').remove()  // 剔除某个元素
$('div').clone()  // 包括文字也会被复制，其中还有个参数，如果是true则事件也仪器复制
```



==顺便提一句==

> jquery中创建元素的方式直接**$('<p></p>')**，直接写上标签就行了，还是得注意，这是创建的**jquery对象**，不是dom对象！！！！

## 7.JQuery事件

- 简单添加方法

  ```javascript
  $('ul').click(()=>{alert('!!!')})  // 注册一个点击事件
  $('ul').bind('click mouseover mouseleave', (e)=>{console.log(e)})  // 注册多个事件
  // 他们都有二个参数是data 也就是触发的时候 会给返回jquery对象增加一个一个data属性，值就是设置的那个值
  ```

- on()、delegate()方法

  ```javascript
  $('div').delegate(目标标签，事件类型， 事件函数) 
  /***********************************************/
  $('div').delegate('p'，'click'， function () {
     alert('!!!!'); 
  });
  // 相当于
  document.querySelector('.css1').addEventListener('click', function (e) {
      if(e.target.nodeName === 'P') {  // 注意这里的判断 jquery代替的这一步
          alert('!!!!');
      }
  });
  // 也就是指定的某个元素触发事件才有效
  $(selector).toggle(function1(),function2(),functionN(),...)  // 点击这个元素，轮流切换响应事件函数
       													// 1.9以后这个方法只能显示或者隐藏
  ```

  ==使用on()可以完全代替其他注册方法==

  ```javascript
  $('.css1').on('click', ()=>{alert('!!!')})  // 普通注册事件
  $('.css1').on('click','i', ()=>{alert('!!!')}) // 代理模式，注意和delegate的前两个参数是反的
  $('.css1').on('click mouseover mouseleave','i', ()=>{alert('!!!')})  // 多个事件解绑
  ```

- 解绑事件

  ```javascript
  由on()方法注册的事件可以由off()方法移除
  
  其他的就$().click = null
  ```

- 阻止冒泡和默认行为

  ```javascript
  event.stopPropagation()
  event.preventDefault()  // 通用的和原生js
  ```

## 8.JQuery获取特殊属性

```javascript
$('div').val() // 获取value值
$('div').val('XXX') // 设置value值
$('div').text()  // innerText
$('div').html()  // innerHTML
$('html, body').animate({scrollTop:0})  // 回到顶部
```

## 9.JQuery动画

- 基本动画

  ```javascript
  $(selector).hide(speed,callback); // 隐藏
  $(selector).show(speed,callback);   // 显示
  $(selector).toggle(speed,callback,switch)  // 切换隐藏显示
  $(selector).slideDown/Up(speed,callback);   // 上下卷动
  $(selector).slideToggle(speed,callback);  // 卷动切换
  $(selector).fadeIn/Out/Toggle(speed,callback);   // 淡入淡出、出入切换
  ```

- 自定义动画

  ```javascript
  $(selector).animate({params},speed,callback)  // 动画方法
  // 使用 marginRight 而不是 margin-right
  // 多个动画罗列在一起，形成了动画队列
  .stop().animate()  // 停止当前动画  实际上多在开始一个新动画之前加，为了停止前一个动画
  .clearQueue(queuename)  // 清除队列，保持清除前的一帧
  .jumpToEnd()  // 调到动画的最后一帧
  ```

  

## 10.JQuery其他操作

```javascript
$('div').prevAll(selector)  // 获取div前面的所有兄弟元素
$('div').prevUtil(selector)  // 获取div前面的所有兄弟元素，直到某个元素
// parent也有类似方法
$('div').find('p').end()  // 返回上一次的选择，相当于div-->div中的p-->div
$('div').each(function(elemnt, index){...})  //  为所有的选择的div
```

## 11.其他

- 自制插件

```javascript
jQuery.prototype.xxx = function() {..}  // 给原型增加自己的函数
```

----

# AJAX基本

---

## 1.原生写法

```javascript
var xhr = new XMLHttpRequest;  // 示例XMLHttpRequest对象
xhr.open('POST', '/xxx');  // 连接路径 设置请求方式
// 设置请求头 设置发送的数据格式 POST请求时要注意这个格式的设置
xhr.setRequestHeader('content-Type', 'application/Json')  
xhr.send();  // 发送
xhr.onreadystatechange = function() {  // 注册状态改变事件
    if(this.readyState === 4) {  // 请求完全完成时
        var text = xhr.responseText // 响应体
    }
}
// 注意所有操作都是异步的

var xhr = new XMLHttpRequest;  // 示例XMLHttpRequest对象
xhr.open('GET', '/xxx');  // 连接路径 设置请求方式
xhr.send("key1=value1&key2=value2&...");  // 发送请求，这里是按照json格式发送
xhr.onreadystatechange = function() {  // 注册状态改变事件
    if(this.readyState === 4) {  // 请求完全完成时
        var text = xhr.responseText // 响应体
    }
}

JSON.parse()  // 将json字符串转化为json格式  json字符串必须是单引号'{"key":value}'
JSON.stringify()  // 将json转化为json字符串
```

## 2.响应状态码

| 响应状态码 readyState |                             意义                             |
| :-------------------: | :----------------------------------------------------------: |
|           0           |                        初始化对象 new                        |
|           1           |                      已经建立连接 open                       |
|           2           | 接收到了响应头<br>.getResponseHeader()<br>.getAllResponseHeadders() |
|           3           |                        正在下载响应体                        |
|           4           |                        一切都已经完成                        |

## 3.JQuery中的Ajax

- $.ajax

  ```javascript
  $.ajax({
      url:'/ss/ss' ，// 请求地址
      type:'POST'，  // 请求方式
      sucess:function(){...} ， // 请求成功后的回调函数
      complete:function(){...}, // 请求完成，无论成功还是失败
      data:'&foo=bar1&foo=bar2' ， // 请求数据
      dataType:'json'/'jsonp'/'xml'...  ， // 响应的数据类型
      contentType:'application/x-www-form-urlencoded' ， // 发送编码类型
      beforeSend: function () { // 发送之前的操作，也可以修改请求头
          // 禁用按钮防止重复提交
          $("#submit").attr({ disabled: "disabled" });
      }，
      jsonp:function(){}  // 指定jsonp的回调函数
  })
  ```

- $.get()和\$.post()
```javascript
$.get(url,data,success(response,status,xhr),dataType)  // get
$(selector).get(url,data,success(response,status,xhr),dataType)  // 指定某个元素中使用get到的数据

$.post(url,data,success(data, textStatus, jqXHR),dataType)  // post不能指定某个元素使用数据
```

- $.load()

  ```javascript
  $("#result").load("ajax/test.html #container");
  // 在id为result的元素中，加载ajax/test.html地址的页面中，的id为container的部分
  ```

- 全局事件处理函数

  ```javascript
  $(document).ajaxStart(function(){})  // 请求发生时执行
  $(document).ajaxStart(function(){})  // 请求结束时执行
  ```

## 4. 请求和接收响应的一些问题

- 无论是请求还是响应，浏览器和服务端之间的信息交互都是以**字符串的形式**，所以在传递如JSON数据时

- 使用`JSON.stringify()`和`JSON.parse()`

  ```javascript
  // 浏览器发送前
  xhr.send(JSON.stringify(jsonObj))
  // 浏览器接收到响应后
  JSON.parse(xhr.responseText)  
  ```

- 表单数据

  每个表单控件都应该有`name`属性，这因为当表单自己提交数据的时候，是按照“name1=value1&name2=value2...”来发的，如果没有name属性，传输数据就会出错

---

# Node.js基本

------

## 1.原生构建服务

```javascript
var http = require('http');  // 引入http组件
var server = http.createServer();  // 实例服务对象

server.listen(3000, function(){  // 监听端口3000，运行成功时执行回调函数
    console.log('127.0.0.1:3000');
});

server.on('request', function(req, res) {  // 注册请求监听器 回调函数两个参数request和response
    if(req.url === '/') {  // 首页请求'/'时执行函数 req.url 获取请求路径端口号后面那串
        console.log('hello');
        res.setHeader('content-Type', 'text/plain:charset=utf-8') // 告诉浏览器编码格式
        res.end('!!!');  // 响应内容 get方法请求的响应会直接显示在浏览器上
    }
});
```

```javascript
var http = require('http');
var fs = require('fs');
var server = http.createServer();
server.on('request', function(req, res) {
    if(req.url === '/') {
        console.log('hello');
        fs.readFile('./demo/test.html', function(err, data) {  // 增加一个文件读取
            if(err) return res.end('错误');
            else res.end(data.toString());  // 必须将读取的数据字符串化，不然都是二进制数据
        })
    }
});
server.listen(3000, function(){
    console.log("http://127.0.0.1:3000/");
});

```

- request对象
  - req.scoke.remotPort/.remotAddress  获取请求端口和ip
- response对象
  - res.statusCode = 302  设置http状态码
  - res.setHeader('location', '/') 设置响应头  这里相当于重定向
  - res.end()

## 2.url模块

```javascript
var url = require('url');
url.parse('https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=ss&rsv_pq=d609a65a00041ba2&rsv_t=4b6cS16HIl4uXDGDgt2pCbCDrSoGzh3IJ5Cw5P6hyHQMYqgFvRNgDaSoYUQ&rqlang=cn&rsv_enter=1&rsv_sug3=2&rsv_sug1=1&rsv_sug7=100&rsv_sug2=0&inputT=9&rsv_sug4=1598')  // 比如使用parse()方法
//输出>>>>
Url {
  protocol: 'https:',
  slashes: true,
  auth: null,
  host: 'www.baidu.com',
  port: null,
  hostname: 'www.baidu.com',
  hash: null,
  search: '?ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=ss&rsv_pq=d609a65a00041ba2&rsv_t=4b6cS16HIl4uXDGDgt2pCbCDrSoGzh3IJ5Cw5P6hyHQMYqgFvRNgDaSoYUQ&rqlang=cn&rsv_enter=1&rsv_sug3=2&rsv_sug1=1&rsv_sug7=100&rsv_sug2=0&inputT=9&rsv_sug4=1598',
  query: 'ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=ss&rsv_pq=d609a65a00041ba2&rsv_t=4b6cS16HIl4uXDGDgt2pCbCDrSoGzh3IJ5Cw5P6hyHQMYqgFvRNgDaSoYUQ&rqlang=cn&rsv_enter=1&rsv_sug3=2&rsv_sug1=1&rsv_sug7=100&rsv_sug2=0&inputT=9&rsv_sug4=1598',
  pathname: '/s',
  path: '/s?ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=ss&rsv_pq=d609a65a00041ba2&rsv_t=4b6cS16HIl4uXDGDgt2pCbCDrSoGzh3IJ5Cw5P6hyHQMYqgFvRNgDaSoYUQ&rqlang=cn&rsv_enter=1&rsv_sug3=2&rsv_sug1=1&rsv_sug7=100&rsv_sug2=0&inputT=9&rsv_sug4=1598',
  href: 'https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=ss&rsv_pq=d609a65a00041ba2&rsv_t=4b6cS16HIl4uXDGDgt2pCbCDrSoGzh3IJ5Cw5P6hyHQMYqgFvRNgDaSoYUQ&rqlang=cn&rsv_enter=1&rsv_sug3=2&rsv_sug1=1&rsv_sug7=100&rsv_sug2=0&inputT=9&rsv_sug4=1598' }
// 这么大堆其实也就 pathname: '/s' 这一句有用
// 因为get请求的时候，特别是表单的get请求，在请求路径后面会跟着一串数据，如这里的/s?....
// 而我们需要根据请求路径来响应，所以我们只需要提取出/s，使用这个方法就可以解析地址
// query属性就是请求发送的数据  
```

## 3.关于路径

```javascript
// 因为node运行有个路径，安装的那些包运行的时候也有自己规定的路径
// 所以直接写相对路径很容易出现混乱 导致错误
// 终极解决办法就是使用包path和常量__dirname来确定路径
__dirname // 当前项目的路径 通俗来讲就是这个js文件载哪个文件夹
var path = require('path')
path.join(__dirname, '...')  // 这样就组成了一个路径
```



----

# Express入门

----

## 1.基本构建服务

```javascript
var express = require('express'); //引入包
var app = express();  // 创建对象
app.listen(3000, ()=>{console.log('http://127.0.0.1:3000')});  // 监听
app.get('/', (req, res)=>{  // 响应请求  
    res.send(req.url);  // 这里的send方法 自动设置了编码格式
});
// get 和 post 返回的依然是express对象 所以
app
    .get('', fn)
	.post('', fn)
	.get('', fn).....// 一直调用下去
```

## 2.设置公开目录/静态资源

```javascript
...
// 第一个参数是请求路径 也就是地址栏的那个,随便写名字
// 第二个参数是公开目录的dir
app.use('/static/', express.static('./public/'))
// 当省略第一个参数时 默认是响应/public/
```

## 3.路由

- 在router.js中定义

  ```javascript
  var express = require('express'); 
  var router = express.Router();  // 创建router容器
  router.get('/', (req, res)=>{  // router.get/post 代替 app.get/app.post
      fs.readFile(path.join(__dirname, '../index.html'), (err, data)=>{
          if(err) return console.log(err)
          else res.send(data.toString());
      });
  })
  
  router.post('/data', (req, res)=>{
      db.findData(req.body, (err, ret)=>{
          if(err) console.log(err);
          else res.send(ret)
      });
  })
  module.exports = router;  // 导出router容器
  ```

  

- 在app.js中使用router

  ```javascript
  var router = require('./router/router');
  app.use(router); // 路由
  ```

  

## 4.一些小碎片

### 4.1 express中的art-template

```javascript
// 要安装两个包 art-template和express-art-template
// 然后
app.engine('art', require('express-art-template'))  // 第一个参数表示读取以art为扩展名的文件 可以随便取
												// 第二个参数就是引入express-art-template包
// 在响应里面写
res.render('XX.art', value)  // 第一个参数是渲染的模板文件 默认是放在views文件夹中 当然也可以改
						   // 第二个就是放入模板的数据
// 修改views文件夹
app.set('views', path)
```

```html
// 在HTML中
{{each data}}
	<i>{{$value.name}}</i>
{{/each}}
// 在js中
var a = {{'name':xxx, 'age':xxx}, {'name':ooo, 'age':ooo}}
res.render('xx.html', { data:a})
<!--输出为-->
<i>xxx</i>
<i>ooo</i>
```

### 4.2 get请求体和post请求体

- get

  ```javascript
  // 很简单
  req.query // 这个属性中的请求体已经被转化为了json格式
  ```

- post

  ```javascript
  // 借助express的中间件body-parser
  // 先安装
  // 然后
  var bodyParser = require('body-parser');
  // 配置
  app.use(bodyParser.urlencoded({extended:false}));
  app.use(bodyParser.json());
  // 然后再响应的时候就可以这样写
  req.body  // 请求对象就有了body属性 就可可以看到请求体
  ```

  ==注意==

  ​	中间件的目的是在浏览器和服务器之间插入一些属性或者其他的东西，所以**中间件**一定要放**在响应操作之前**

### 4.3 重定向

```javascript
res.redirect('/')
```

---

# MongoDB

## 1. 简单起步

1. cmd/powershell 输入 mongod 回车

   默认是开启这个磁盘里的x:/data/db/，如果没有是无法开启服务的。

   修改路径 mongod --dbpath=路径

2. 在node中连接数据库

   1. npm i --save-dev mongoose
   2. 具体使用下面单独讲

### 1.1 mongoose

 1.  创建一个数据库模板

     ```javascript
     // 可以在单独的一个文件中 定义模板
     var mongoose = require('mongoose'); // 引用包
     var schema = mongoose.Schema;  // 取个名字而已
     var sale = new schema({  // new 一个Schema类
         product: {        // 可以定义一些约束
             type:String,  // 输入数据类型
             required:true // 是否必须  // 还能设置默认值 default:xxxx
         },
         region: {
             type:String,
             required:true
         },
         sale: {
             type:Array,
             required:true
         } 
     });
     // 第一个参数大写首字母单数(约定)，第二个参数模板类，最后会在数据库生成一个复数集合
     var saleModel = mongoose.model('Sale', sale); // 将自定义的schema转化为模板对象
     										// 就是这里的saleModel,之后都是根据它来操作
     module.exports = saleModel;  // 导出模板对象 方便其他文件使用
     ```

	2. 操作数据库

    ```javascript
    var mongoose = require('mongoose');
    var saleModel = require('../schema/schema'); // 引入刚才的模板文件
    // 连接数据库
    mongoose.connect('mongodb://localhost/ife');  // 先连接数据库 /ife为数据库名 如果不存在就会创建一个
     
    /**
     * 增加数据 
     */
    function addData(input) {
        var data =  new saleModel(input);  // new一个模板对象 把新数据传入
        data.save((err)=>{if(err) console.log(err)});  // newData.save(callback) 存储数据
    }
    
    /**
     * 查找数据
     */
    function findData(condition, callback) {
        // 因为要取异步操作的数据，所以增加一个回调函数
        saleModel.findOne(condition, (err, ret)=>{  //  Model.findOne(condition, callback)
            if(err) callback(err, null);		 // 参数condition可以是任意
            else callback(null, ret)
        })
    }
    
    /**
     * 删除数据
     * @param {object} condition 
     */
    function deleteData(condition) {
        saleModel.remove(condition, (err)=>{if(err)console.log(err)});  // 和查找很像
    }
    
    /**
     * 更新数据
     */
    function update(condition, newdata) {
        saleModel.updateOne({_id:condition}, {$set:{'sale':newdata}}, (err)=>{if(err)console.log(err)});// 这里首先按照_id查找， 然后更新sale部分,{$set:{...}}是数据库操作符
    }
    ```


​    

----

# LocalStorage

> 数据存储在 `localStorage` 是无期限的，而当页面会话结束——也就是说当页面被关闭时,数据存储在`sessionStorage` 会被清除 。 

```javascript
localStorage.setItem('myCat', 'Tom');  // 存储
var cat = localStorage.getItem("myCat");  // 读取
localStorage.removeItem("myCat");  // 移除
// sessionStorage一样的用法
```

==注意==

- 正确存储对象到localstorage的方法是先把对象转化为字符串`JSON.stringify`

---

# Location 对象

## 1. 总体

```javascript
function currLocation()
{
alert(window.location)  // 什么都写 返回当前的url
}
function newLocation()
{
window.location="/index.html"  // 写了就会连接至新地址  相对与当前ip的
}
```

| 属性                                                         | 描述                                          |
| ------------------------------------------------------------ | --------------------------------------------- |
| [hash](http://www.w3school.com.cn/jsref/prop_loc_hash.asp)   | 设置或返回从井号 (#) 开始的 URL（锚）。       |
| [host](http://www.w3school.com.cn/jsref/prop_loc_host.asp)   | 设置或返回主机名和当前 URL 的端口号。         |
| [hostname](http://www.w3school.com.cn/jsref/prop_loc_hostname.asp) | 设置或返回当前 URL 的主机名。                 |
| [href](http://www.w3school.com.cn/jsref/prop_loc_href.asp)   | 设置或返回完整的 URL。                        |
| [pathname](http://www.w3school.com.cn/jsref/prop_loc_pathname.asp) | 设置或返回当前 URL 的路径部分。               |
| [port](http://www.w3school.com.cn/jsref/prop_loc_port.asp)   | 设置或返回当前 URL 的端口号。                 |
| [protocol](http://www.w3school.com.cn/jsref/prop_loc_protocol.asp) | 设置或返回当前 URL 的协议。                   |
| [search](http://www.w3school.com.cn/jsref/prop_loc_search.asp) | 设置或返回从问号 (?) 开始的 URL（查询部分）。 |

- href描述的是当前网页的完整地址
- 其他属性就是url的各个部分

## 2.hash

### 2.1 URL 的锚部分（从 # 号开始的部分） 

```javascript
　http://www.example.com/index.html#print
// 网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域
```

```html
// 指定锚点
<a name="print"></a> // 给a标签名字
<div id="print" > // 给id
```

### 2.2 注意点

-  **HTTP请求不包括#** ，是用来指导浏览器动作的，对**服务器端完全无用**
- 在第一个**#后**面出现的**任何字符**，都会被浏览器解读为位置标识符 
- 改变#**不触发**网页**重载** 
- 改变#**会改变**浏览器的**访问历史**  使用"后退"按钮，就可以回到上一个位置  可以使用`ajax`get请求hash
- window.location.hash这个属性可读可写。**读取**时，可以用来判断网页**状态是否改变**；**写入时**，则会在不重载网页的前提下，**创造**一条访问**历史记录** 
- onhashchange事件 当#值发生变化时触发
- 谷歌中使用hash，用`#！`代替`http://twitter.com/#!/username`

----

# H5中的pushState()，replaceState()和popstate()

- pushState()  replaceState()就是替换history条目

  ```javascript
  var state = { 'page_id': 1, 'user_id': 5 };
  var title = 'Hello World';
  var url = 'hello-world.html';
  history.pushState(state, title, url);
  // state: 它存储JSON字符串，可以用在popstate事件中 最多存储64kb
  // title: 最好用null代替
  // url: 新的URL不一定要是绝对地址，如果它是相对的，它一定是相对于当前的URL
  // 新URL必须和当前URL在同一个源下;否则，pushState() 将丢出异常
  ```

- popstate() 当前活动历史项(history entry)改变**（前进，后退）**会触发popstate事件 

  - 调用`history.pushState()` 或 `history.replaceState()`,那么事件参数里就会有`e.state`，其中包含上面设置的state对象 

---

# SVG

----

## 1.初识SVG

```xml
<svg version="1.1"  版本号必须的
     baseProfile="full" 这个也是必须的
     width="300" height="200" 规定整张svg的大小
     xmlns="http://www.w3.org/2000/svg"> 

  <rect width="100%" height="100%" fill="red" />  矩形 注意标签是单个的 

  <circle cx="150" cy="100" r="80" fill="green" /> 圆

  <text x="150" y="125" font-size="60" text-anchor="middle" fill="white">SVG</text>  文字

</svg>
```

==渲染顺序==

	>“后来居上”，越后面的元素越可见

## 2.插入html中

```html
<object data="image.svg" type="image/svg+xml" />
或者
<iframe src="image.svg"></iframe>
```

## 3.服务器请求

```
Content-Type: image/svg+xml
Vary: Accept-Encoding
```

## 4.简单图形

```xml
    <rect x="60" y="10" rx="10" ry="10" width="30" height="30" />
	<!-- 矩形 x,y左上顶点坐标 rx、ry圆角的x，y方向上的半径-->
```

```xml
    <circle cx="100" cy="100" r="20"/> 	<!-- 圆 cx、cy圆心坐标 r半径-->
	<ellipse cx="75" cy="75" rx="20" ry="5"/> <!-- 椭圆 cx、cy圆心坐标 rx、ry椭圆x，y半径-->
```

```xml
	<line x1="10" x2="50" y1="110" y2="150"/> <!-- 直线 x1\y1 x2\y2 分别代表起始和终止坐标-->
```

```xml
	<polyline points="60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145"/>	<!-- 折线 就是多个点组成的-->
<polygon points="50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180"/>
	<!-- 多边形 唯一与折线的区别就是 最后一个点会自动连接到第一个点-->
```

## 5.Path标签

### 5.1简单认识

```xml
<path d="M250 150 L150 350 L350 350 Z" />	<!-- path标签 首先由d属性确定-->
										<!-- d属性的值是一个“命令+参数”的序列-->
```

> 每一个命令都有两种表示方式，一种是用**大写字母**，表示采用**绝对定位**(相对于画笔第一个位置)。另一种是用**小写字母**，表示采用**相对定位** (相对于画笔的上一个位置)

### 5.2直线指令

- M ：Move to 

  将画笔移动到Mx y这个点，或者mx y。并不会画出实际的东西

- L：Line to 

  从当前位置画到L x y (l x y)。

- 水平线和垂直线

  从当前位置水平延伸到Hx hx

  从当前位置垂直延伸到Vy vy

- Z

  闭合路径，把最后一点连接到起始

  ```xml
  <path d="M10 10 h 80 v 80 h -80 Z" fill="transparent" stroke="black"/>
  ```

### 5.3曲线指令

- C：三次贝塞尔曲线

  C x1 y1, x2 y2, x y

   x1 y1：起始端控制点         

  x2 y2：结束端控制点

  x y：曲线终点

  ![1527430366373](/1527430366373.png)

- S：连接多个三次贝赛尔曲线

  S x2 y2, x y (or s dx2 dy2, dx dy)

  必须跟在一个S或者C后面，S的

  第一个点会成为上一个曲线最后的控制

  点的对称点

  ![1527431008301](/1527431008301.png)

- Q ：二次贝塞尔曲线

  Q x1 y1, x y (or q dx1 dy1, dx dy)

  只有一个控制点

  ![1527431103105](/1527431103105.png)

- T：连接多个二次贝塞尔曲线

  T x y (or t dx dy)

  ![1527431186640](/1527431186640.png)

### 5.4弧形指令

- A

  A rx ry x-axis-rotation large-arc-flag sweep-flag x y

  x y：弧形的终点

  rx/ry：和椭圆一样，x或y轴半径

  x-axis-rotation：绕x轴旋转度数，如图中两个椭圆(实际看不到下半圆)，一个没有旋转，另一个旋转了-45°

  

  ![1527431400372](/1527431400372.png)

  large-arc-flag：角度大小 0：取小弧度的弧线 1：取大弧度的

  sweep-flag：弧度方向 0：取逆时针 1：取顺时针

  ![1527431613606](/1527431613606.png)

## 6.DOM操作新增节点

```javascript
var axisPath = document.createElementNS("http://www.w3.org/2000/svg", "path"); 
// 要给命名空间才能正确创建svg节点
```



---

# Canvas 

---

## 1.初识Canvas 

```html
  <canvas id="myCanvas" width="200" height="100"></canvas>
	<!--canvas 标签 只有这几个属性 -->
```

- `在javaScript上使用`

  ```javascript
      /*获取元素*/
      var myCanvas = document.querySelector('#myCanvas');
      /*获取绘图工具*/
      var context = myCanvas.getContext('2d');
      /*设置绘图的起始位置*/
      context.moveTo(100,100);
      /*绘制路径*/
      context.lineTo(200,200);
      /*描边*/
      context.stroke();
  ```

## 2.基本图形

### 2.1矩形

```javascript
.fillRect(x, y, width, height)
    // 绘制一个填充的矩形
.strokeRect(x, y, width, height)
    // 绘制一个矩形的边框
.clearRect(x, y, width, height)
    // 清除指定矩形区域，让清除部分完全透明。 
```

### 2.2路径

> 1. 创建路径起始点
> 2. 然后使用画图命令去画出路径
> 3. 之后你把路径封闭
> 4. 一旦路径生成，你就能通过描边或填充路径区域来渲染图形

- `beginPath()`

​    新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。

- `closePath()`

   闭合路径之后图形绘制命令又重新指向到上下文中。

- `stroke()`

   通过线条来绘制图形轮廓。

- `fill()`

  通过填充路径的内容区域生成实心的图形。 

```javascript
var ctx = canvas.getContext('2d');
ctx.beginPath();
ctx.moveTo(75,50);
ctx.lineTo(100,75);
ctx.lineTo(100,25);
ctx.fill();
// 画出一个三角形
moveTo(x, y)
 //   将笔触移动到指定的坐标x以及y上
```

### 2.3线

- `lineTo(x, y)`

  绘制一条从当前位置到指定x以及y位置的直线。

  ```javascript
   // 填充三角形
   ctx.beginPath();
   ctx.moveTo(25,25);
   ctx.lineTo(105,25);
   ctx.lineTo(25,105);
   ctx.fill();
  
   // 描边三角形
   ctx.beginPath();
   ctx.moveTo(125,125);
   ctx.lineTo(125,45);
   ctx.lineTo(45,125);
   ctx.closePath();
   ctx.stroke();
  ```

### 2.4圆弧

- `arc(x, y, radius, startAngle, endAngle, anticlockwise) `

  以（x,y）为圆心

  以radius为半径的圆弧（圆）

  从startAngle开始到endAngle结束

  按照anticlockwise给定的方向（默认为顺时针）来生成。 

  ==注意==

  > arc()函数中的角度单位是弧度，不是度数。角度与弧度的js表达式:radians=(Math.PI/180)*degrees

```javascript
        context.arc(50, 50, 20, 0, Math.PI * 2, true);
        context.fill(); // 画一个实心圆
```

## 其他

> ```javascript
>         context.beginPath();
>         context.fillStyle = axisColor;  // 先设置了画笔或者填充颜色再画 不然设置无效
>         context.strokeStyle = axisColor;
>         context.moveTo(dataX, axisHeight - 10);
>         context.lineTo(dataX, axisHeight+5);
>         context.font='16px microsoft yahei';
>         context.fillText(`${index+1}月`, dataX - 10, axisHeight+20);
>         context.stroke();
>         context.fill();
> 		
> ```
>
> 



---



# JS中的碎片

----

## 1.扩展运算符

```javascript
[...data]====>[item1, item2, item3]  // 把任意一种列表转化为数组
[...$("div")] ===> Array [<div class="css1">, <div class="css2">]
[...document.querySelectorAll('div')] ===> Array [<div class="css1">, <div class="css2">]
// 利用这个可以把一些不能使用Array对象的集合，转为数组，方便操作
[...maxData.toString()]  // 把一个数字转成字符串，最后分割为数组227===>['2', '2', '7']
```

```javascript
// 还有个用法
// 获取数组中的最大值
var a = [1, 2, 3, 4, 5]
Math.max(...a) // 注意不带中括号，这样就把数组打开了 作为参数输入到了max方法
===> 5
```

==相似==ES6中有一个新的Array对象原型方法，`Array.from()`，将一个**可迭代对象**或者是一个**类数组对象**变成真正的数组

```javascript
//类数组对象:
//就是有个length属性
{
    a:1,
    b:2,
    length:2
}

Array.from(转化目标,相当于map的一个回调函数)
```

还有一个用法

```javascript
// 以前为了不改变原来的数组 需要slice或者其他操作
//直接用扩展运算符就能完全 复制 而且不会影响到原数组
let a = [1, 2, 3]
let b = [...a] //将a直接扩展为另一个一模一样的数组
b.pop()
//打印这两个变量
a=[1, 2, 3]
b=[1, 2]//互不影响
```



## 2.数组的every、some、map、forEach、filter

```javascript
Array.every(function (item, index) {
    return item > 18
})  // 所有的数组元素item 都 大于18才返回 1个 true/否则false
Array.some(function (item, index) {
    return item > 18
})  // 只要有元素大于18就返回 1个 true否则false
Array.map(function (item, index) {
     Math.sqrt(item);
})  // 首先map会返回一个新的数组，和slice一样不会改变原数组
   // 每个元素都会调用函数
Array.forEach(function (item, index) {
     Math.sqrt(item);
}) // 每个元素都会调用函数，也是只调用一下，不会返回新的数组，也不会改变原数组
Array.filter(function (item, index) {
    return item > 18
})  // 返回满足条件的元素
```

## 3.exports和module.exports

- 普通对象的一些性质

  ```javascript
  // 这里有两个对象
  var obj1 = {...};
  var obj2 = {...};
  // 这样操作时，两个对象指向了内存的同一块单元
  obj2 = obj1;
  // 但是对obj2进行这样操作时 两个对象就不再指向同一内存
  // obj1并没有aa这个属性，所以这两个对象不是同一个
  obj2.aa = "sss";
  ```

- 结合上面的例子

  1. 首先每个文件的最后其实都有一个隐藏的一句话

     ```javascript
     return module.exports;
     ```

  2. 所以当我们需要导出东西时，就需要给 module.exports对象赋值

     ```javascript
     module.exports = {
         aaa:aaa,
         aa(){
             ....
         },
         vv:ss,
         sss:121
     }
     ```

  3. 然而为了更加的方便，增加了一个新的对象exports<br>于是 exports 与 module.exports变成了这样的关系

     ```javascript
     var exports = module.exports;  // 这就变成了上面例子的关系
     ```

  4. 所以如果这样

     ```javascript
     exports.aa = function () {
         ....
     }
     // 那么exports 和 module.exports就不是同一个对象了
     ```

  5. ==反正最好不要混用，或者干脆就用module.exports==

## 4.数组操作的一些细节

### 4.1 尽量不操作原数组/字符串

```javascript
var a = [...];
var b = a;
b.pop();  // 尽管表面上看起来是操作的b数组，实际上因为对象的性质（看这一章的第三节）,他们都指向同一个内存
         // 所以操作b也会影响a
// 为了避免影响原数组 使用slice()方法切片数组 保存
var b = a.slice(0)  // 不指定end参数时默认切片到末尾 这样操作b就不会影响a
```

## 5.call()

```javascript
// 比如这种情况
// 有一个构造函数
function aa() {
    this.bb=...;
    ....
}
aa.prototype.cc = function () {
    // 在这里面使用了一个方法，而这个方法会该表this
    // 比如这个foreach，这里面的this指向的是这个数组
    // 所以为了能使用构造函数里面的属性，这里要改变this指向
    [...].forEach(function (item, index) {
 		this.bb.... // 不能直接this.bb
 	});
     // 增加一句
     [...].forEach(function (item, index) {
         aa.call(this); // 这样这里面的this就指向了构造函数
 		this.bb.... 
 	});
}

```

## 6. forEach中看this

上面一个例子在接下来的例子中却不管用

```javascript
// 有一个构造函数
function aa() {
    this.bb=...;
    ....
}
aa.prototype.cc = function () {
    // 在这里面使用了一个方法，而这个方法会该表this
    // 比如这个foreach，这里面的this指向的是这个数组
    // 所以为了能使用构造函数里面的属性，这里要改变this指向
    [...].forEach(function (item, index) {
     	[...].forEach(function (item, index) {
         	 aa.call(this);
 			this.bb.... // 就算是call了一次构造函数，依然无法使用bb属性
 		});
 	});
}
```

==暂时还不知道这是什么原因，但是解决办法是==

```javascript
aa.prototype.cc = function () {
    [...].forEach(function (item, index) {
     	[...].forEach(function (item, index) {
         	 aa.call(this);
 			this.bb....
 		}, this);
 	}, this);
} // 在forEach的第二个参数让回调函数的this，指向调用者
```

- 姑且猜测

  > 第一层的是`数组`调用的forEach函数，所以`this`指向的`这个数组`，`第二层`是第一层数组里的元素调用的forEach所以也是指向的数组。加上this，先使第一层的回调函数指向了这个`原型方法的调用者`，第二层指向了第一层的原型函数的this也就是`间接`指向了原型方法的调用者

- 简单判断this之像谁

  > 如果不确定需不需要重新指定this，可以在编辑器中打出**this.**看看编辑器有没有提示出属性，如果没有提示，就代表this指向已经改变了。

## 7.字符串与数字

==注意==

- 一个字符串类型的数据，如'123','56'....在做计算操作时一定要先**转换**为数字类型，不然如加法，会变成**字符串连接**！！！

## 8. onmousemove 、mouseleave 、onmouseout 

onmousemove 事件在鼠标移动到 **div** 元素上时触发。

 mouseleave 事件只在鼠标指针移出 **div** 元素时触发。 

 onmouseout 事件在鼠标指针移出 **div** 元素及离开**子元素**时触发。

## 9. async 和 await

[主要参考文献1](https://www.cnblogs.com/vipzhou/p/6519552.html)

[主要参考文献2](https://segmentfault.com/a/1190000007535316)

1. **首先**每个函数都可以返回一个`Promise `类

   ```javascript
   function A() {
       return new Promise((resolve, rejects)=>{// 回调函数两个参数resolve和rejects
           .......
           resovle(....)  // 这里的resovle后面解释
       })
   }
   ```

2. **然后**`async` 修饰的函数本身返回值就是Promise 类

   其实最重要的是**只有它修饰过**的函数才能用`await`

   ```javascript
   // async修饰的函数
   async function A() {
       var a = "aaa";  // 随便什么值都一样
       return a // 直接返回没有意义  只是一个Promise 类 里面包含这个异步函数是否执行完成
   }			// 所以想要直接获取async修饰的函数的返回值是很困难的 反正我不知道怎么获取
   
   // 只有在async修饰过的函数中才能用await关键词
   ```

3. `await`就是等待，等待函数的返回值，但是等待的函数返回的如果是Promise 类

   那么他等的就是**Promise .resolve,** 而且还要**等待这个函数执行完了才进行下一步**

   也就是**会阻塞**后面

   ```javascript
   // 在b中可以放个异步函数，输出由resovle传递
   function B() {
       return new  Promise((resolve, rejects)=>{
         var a = '!!!'
         resovle(a) 
       };
   }
   // 在 async中
   async function A() {
       var a = await B();  // 有了await 没有等到resovle传递的数据就不会下一步
       console.log(a)  // 这里不能直接return a 和上面说的一样 只会返回一个Promise 类
   }
   //输出>>>>'!!!!' 
   ```

4. 示例

   ```javascript
   function asyncFunc (arr, i) { // 普通函数
       return new Promise(function(resolve, reject) {  // 返回一个Promise 类
           setTimeout(function() {  // 模拟一个异步函数
               arr.push(i);
               console.log("index is : ", i);
               resolve();  // 这里没有传递实际参数 但是也必须写 不然await一直等
           }, 1000);
       });
   }
    
   var box5 = async function() {  // async修饰的异步函数
       var arr = [];
       for (var i = 0; i < 5; i++) {  // 这是一个循环 循环是同步操作 正常情况下 
           await asyncFunc(arr, i);  // 如果循环里面有异步函数 循环不会等异步函数
       }                             // 也就是说 异步函数还没有执行完 有可能循环已经完成了
       console.log(arr);     // 这里可以看到使用了 await 也就是说每次循环执行到这里就会等待
   }                         // 直到异步函数完成 相当于阻塞了后面程序
    
   box5();
   
   ```

   - 我自己的一个例子

   ```javascript
   // 现在有三个函数
   function update(){}
   function ajax(){}
   function main(){}
   // 首先 ajax() 这里面是ajax的一些函数 肯定是异步的
   // 所以使用 return 一个Pormise类来让 update函数等待 之后才能更新
   function ajax() {
       return new Pormise((resolve, reject)=>{
           ....ajax操作...
           resolve(ajax响应结果)
       })
   }
   // 然后 update() 接收
   // 这里也解释了为什么要使用async修饰 因为需要循环这个一步操作
   async function update() {
       for (x of range) {
          var a = [];
         a.push (await ajax()）; // 这些操作就和示例一一样
       }						// 每一次循环都等待 ajax()的返回值
   }
   // 最后问题来了 我要怎么把update()的数据读出来呢
   // 前面说过不能直接return 因为async修饰的函数只会返回Pormise类
   // 最后我发现 可以让宁外一个函数再等待update()的Pormise
   // update()就可以这样写
   async function update() {
       for (x of range) {
          var a = [];
         a.push (await ajax()）; 
       }	
    	return new Promise((resolve, reject)=>{
             resolve(a)  // 这样就可以输出了
         })
   }
   // 使用另外一个函数接收 
   // 注意加上async 不然用不了await
   async function main() { 
   	var b = await update();
       //  然后接下来就可以在这个函数里面任意使用这个值了
   }
   ```



## 10. 进制转换

```javascript
let a = 10;
console.log(a.toString(2)); // 转二进制
console.log(parseInt('1111', 2)); // 转十进制
```

## 11. Object.defineProperty(obj, prop, descriptor)

### 参数

- `obj`

  要在其上定义属性的对象。

- `prop`

  要定义或修改的属性的名称。

- `descriptor`

  将被定义或修改的属性描述符。

### 返回值

​    被传递给函数的对象。

第三个参数可选的设置

{`configurable` /`enumerable` /`value` /`writable` }

可以被删除或者重新定义/可以被枚举/设置的值/可以做赋值运算

## 12.箭头函数的一些问题

```javascript
// 如果使用function定义函数
var a = {
    a:1,
    function bb(){
    console.log(this.a)  // 在这个对象里 this就指向的对象
}
}
a.bb()
// 输出就会是1
// 如果用箭头函数
var a = {
    a:1,
    bb：()=>{
    console.log(this.a)  // this将不指向对象a  而是父级作用域(a的作用域)的上下文 window
}
}
a.bb()
// 输出将是undefined
```

## 13.对象继承

第一种方法：`call()`

```javascript
// 在构造函数里 call另一个构造函数
function aa(A, B, C) {
    // 这是另一个对象的构造函数
    bb.call(this,A, B)
    this.C = xxx
}
```

==但是==这样做只能继承属性，要继承方法可以这样：

```javascript
//在上面的基础上加上
Teacher.prototype = Object.create(Person.prototype);
Teacher.prototype = Person.prototype；//相当于
// 这样Teacher的原型继承了所有Person的属性和方法
```

==还需改进==：使用` Object.create`方法创造的对象`this`仍然指向Person，如上面的第二句代码，两个对象是一样的，都指向同一块内存，所以`this`指向不变

```javascript
// 所以改变this指向Teacher的构造函数
Teacher.prototype.constructor = Teacher;
```

```javascript
//  据说是最佳的方法
//继承原型
  function extend(subType, superType) {
    function F(){};
    F.prototype = superType.prototype;  // 现在这个F类完全指向了超类
 									// 等于超类
    var prototype = new F;
    prototype.constructor = subType;// 将这个F类的构造属性指向子类
    subType.prototype = prototype;// 再把超类 给子类
   // 优点就是只需要调用一次就继承 不会像写在构造函数里面一样 new一个继承一次
  }
 
  //超类方法
  function SuperType(name) {
    this.name = name;
    this.colors = ["red", "blue", "green"];
  }
  SuperType.prototype.sayName = function() {
    return this.name;
  }
 
  //子类方法
  function SubType(name, age) {
    SuperType.call(this, name);
    this.age = age;
  }
 
  //继承超类的原型
  extend(SubType, SuperType);
 
  //子类方法
  SubType.prototype.sayAge = function() {
    return this.age;
  }
 
  var instance1 = new SubType("Shelby");
  var instance2 = new SubType("Court", 28);
 
  instance1.colors.push('black');
 
  alert(instance1.colors); //red,blue,green,black
  alert(instance2.colors); //red,blue,green
 
  alert(instance1 instanceof SubType); //true
  alert(instance1 instanceof SuperType); //true
```

[几种继承方法](http://www.jb51.net/article/88295.htm)

## 14. 解构赋值

```javascript
let [a, b] = [10, 20]; // 同时给多个变量赋值  顺序是有关系的
let [a, b, ...rest] = [10, 20, 30, 40, 50];// =>10,20，[30, 40, 50] //多余的合并到加了...的变量里
let ({ a, b } = { a: 10, b: 20 });//=>a=10，b=20//注意键，一定要对应
let ({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});// 和数组一样，a=10，b=20，rest={c:30，d:40}

let x = [1, 2, 3, 4, 5];
let [y, z] = x;//可以直接取出一维数组的值 y=1，z=2

let [a=5, b=7] = [1];// 可以给一个默认值 防止右边有undefined =>a=1，b=7

let a = 1;
let b = 3;
[a, b] = [b, a];//可以交换了两个变量的值 => a=3, b=1  //不用再来个中间temp变量

function f() {
  return [1, 2, 3];
}// 一个函数返回一个数组
let [a, b] = f(); //运用解构 =>a=1，b=2
let [a, , b] = f();// 甚至还能忽略某些值 =>a=1，b=3


/*****************解构对象****************************/
let o = {p: 42, q: true};
let {p, q} = o; // 解构对象 =>p=42，q=true//键名要对应上//解构的结果不是对象了，是一个个单独的变量

let ({a, b} = {a: 1, b: 2});//字面量解构 // 要用（）包围
let {a = 10, b = 5} = {a: 3};//同样可以有默认值
let {a:aa = 10, b:bb = 5} = {a: 3};//还能给新的键名换个名字=>aa=3,bb=5


/*********************解构函数参数  会有点难理解************************************/
//注意左边虽然是{}包围的 但是里面不是key:value而是key=value
function drawES2015Chart({size = 'big', cords = { x: 0, y: 0 }, radius = 25} = {}) 
{
  console.log(size, cords, radius);//=>size='big',cords={ x: 18, y: 30 },radius=30
  // do some chart drawing
}

drawES2015Chart({//我们调用了drawES2015Chart函数 传入参数{cords: { x: 18, y: 30 },radius: 30}
  cords: { x: 18, y: 30 },
  radius: 30
});
// 观察到 声明drawES2015Chart的时候 形参是{size = 'big', cords = { x: 0, y: 0 }, radius = 25} = {}
// 是一个解构对象，但是右边是空的，这是用来传入参数的
// 当传入参数的时候，如这里：
//{size = 'big', cords = { x: 0, y: 0 }, radius = 25}={cords: { x: 18, y: 30 },radius: 30}
//最后就被解构成了单独的变量


/**************************嵌套对象和数组****************************************/
var metadata = {
    title: "Scratchpad",
    translations: [
       {
        locale: "de",
        localization_tags: [ ],
        last_edit: "2014-04-14T08:43:37",
        url: "/de/docs/Tools/Scratchpad",
        title: "JavaScript-Umgebung"
       }
    ],// translations是一个数组对象
    url: "/en-US/docs/Tools/Scratchpad"
};
//首先这里重命名的title变为了englishTitle
// englishTitle获取了第一个值title的Scratchpad
//localeTitle获取了第二个值 translations里面的title 
//并把title重命名为localeTitle
var { title: englishTitle, translations: [{ title: localeTitle }] } = metadata;

console.log(englishTitle); // "Scratchpad"
console.log(localeTitle);  // "JavaScript-Umgebung"


/***********************For of 迭代*************************************/
var people = [
  {
    name: "Mike Smith",
    family: {
      mother: "Jane Smith",
      father: "Harry Smith",
      sister: "Samantha Smith"
    },
    age: 35
  },
  {
    name: "Tom Jones",
    family: {
      mother: "Norah Jones",
      father: "Richard Jones",
      brother: "Howard Jones"
    },
    age: 25
  }
];
// 接收people值的变量 变成了解构变量 这里依旧重命名了变量
for (var {name: n, family: { father: f } } of people) 
{
  console.log("Name: " + n + ", Father: " + f);
}

// "Name: Mike Smith, Father: Harry Smith"
// "Name: Tom Jones, Father: Richard Jones"


/*******也可以直接获取参数*******/
function userId({id}) {
  return id;//直接获取了id//注意这里{id}意思是取实参的id属性
}

function whois({displayName: displayName, fullName: {firstName: name}}){
  console.log(displayName + " is " + name);
}

var user = { 
  id: 42, 
  displayName: "jdoe",
  fullName: { 
      firstName: "John",
      lastName: "Doe"
  }
};

console.log("userId: " + userId(user)); // "userId: 42"
whois(user); // "jdoe is John"
```

## 15.对象取值

```javascript
//我们都知道 对象有两种取值方式[]和.
// 有时会会忘记可以直接在字面量上面取
{a:111,b:222}["a"];
let x = "a"
{a:111,b:222}[x];
```

## 16.闭包

https://www.cnblogs.com/q460021417/p/4154340.html

https://www.cnblogs.com/giggle/p/5452271.html

一个函数内部的变量，在外部是无法被访问到的，但是**闭包**可以说是**一个连接的桥梁**，比如例子中，**return了一个对象**，当然也可以只返回一个函数，这个对象里面的方法在函数内部使用了函数内部的变量，但是我们在外面`.`这个方法的时候仍然能得出结果。

闭包有个特性，不会在没使用里面函数的时候，加载里面函数和方法，因为你只是声明了没有使用

```javascript
        var Counter = (function() {
        var privateCounter = 0;
        function changeBy(val) {
            privateCounter += val;
        }
        return {
            increment: function() {
            changeBy(1);
            },
            decrement: function() {
            changeBy(-1);
            },
            value: function() {
            return privateCounter;
            }
        }   
        })();// 使用匿名函数包裹 立即执行了{}（）匿名函数

	    var makeCounter = function() {
      	var privateCounter = 0;
        function changeBy(val) {
            privateCounter += val;
        }
        return {
            increment: function() {
            changeBy(1);
            },
            decrement: function() {
            changeBy(-1);
            },
            value: function() {
            return privateCounter;
            }
        }  
        };// 没有立即执行

```

上面两种方法都能使我们间接访问到函数内部的变量，但是两种方法只有一点区别，**是否**在定义时**执行**了这个**匿名函数**。

这样做的作用很简单：

```javascript
//如果是第一种 创建的时候立即执行 只有一个实例
var a = {..}()//那么之后你只能使用这个一个 a变量 然后a.xxx a.ooo来访问函数内部的变量

// 如果是第二种
var b = function(){}
//因为没有立即执行 所以不会返回一个对象
//使用前再执行 这样可以执行多次 创建多个实例
var cc = bb()
var dd = bb()
//每个变量互不影响
console.log(a.value()); /* logs 0 */
a.increment();
a.increment();
console.log(a.value()); /* logs 2 */
a.decrement();
console.log(a.value()); /* logs 1 */
console.log(b.value()); /* logs 0 *///无论a怎么加减 b仍然是0
```

在创建类的时候，可以这样

```javascript
//原始创建 这样每次new的时候都会调用这个构造函数里面那些函数
function MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
  this.getName = function() {
    return this.name;
  };
  this.getMessage = function() {
    return this.message;
  };
}

// 利用闭包 只有在用的时候才会调用
function MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}
MyObject.prototype.getName = function() {
  return this.name;
};
MyObject.prototype.getMessage = function() {
  return this.message;
};

/// 但是闭包会在程序一打开就执行 必须关闭浏览器才会销毁 容易内存泄露
```

## 17.单例

和**20小节工厂模式**一样，属于一种设计模式

单例就是一个类只有一个实例，无论立new多少次，this都指向一个

```javascript
//第一个方法 就是利用上面的闭包 创建一个变量 
var Counter = (function() {
    var privateCounter = 0;
    function changeBy(val) {
        privateCounter += val;
    }
    return {
        increment: function() {
            changeBy(1);
        },
        decrement: function() {
            changeBy(-1);
        },
        value: function() {
            return privateCounter;
        }
    }   
})();// 现在就只能通过Counter.xxx来访问

// 第二种方法
function singletonAccepter( args ){
    //判断Universe.instance是否已存在实例
    if(typeof singletonAccepter.instance === 'object'){// 如果已经创建 就直接返回这个this
        return singletonAccepter.instance;// 主要就是这两个部分
    }			
    this.name = args.name || 'Monkey';
    this.age = args.age || 24;
    singletonAccepter.instance = this;// 主要 如果instance属性没有被赋值this 也就是创建了一个对象
};									//  就在这里赋值

//还有利用new的原理
function singletonAccepter( args ){
    var instance = null;
    var args = args || {};
    this.name = args.name || 'Monkey';
    this.age = args.age || 24;
    //将instance引用创建的实例this
    instance = this;
    //重写构造函数
    singletonAccepter = function(){ // 注意了 这里就是闭包 下面解释
        return instance;		
    }
};
/***********解释一下*********/
比如我们要创建两个实例 当然实际上只会有一个
var a = new singletonAccepter({name:'xx', age:12})
var b = new singletonAccepter({name:'oo', age:15})
//正常情况下 输出应该都是 {name:'xx', age:12}
//第一次创建，也就是a的时候
instance = this
然后构造函数被覆写了，变成了一个闭包 返回上面的instance
//所以第二次创建 b的时候
实际上singletonAccepter变成了 这个覆写的函数也就是直接返回上面的this
而不是再走一遍 instance = this 什么的


// es6
class Restaurant {
    constructor({cash = 0, seats = 0, staffList = []} = {}) {
        this.cash = cash;
        this.seats = seats;
        this.staffList =staffList;
    }
    // 单例接口
    static getInstance(param) {
        if(!this.instance) {
            this.instance = new Restaurant(param);
        }
        return this.instance;
    }
}
//并且继承这个类的时候 子类的实例也是单例 但是子类的单例又和其他的单例相区别
```

## 18.ES6类

和上面有点关联

```javascript
let id = 1;//这是一个父类
class Staff {
    constructor ({name = '', wages = 0} = {}) {
        this.id =  id++;
        this.name = name;
        this.wages = wages;
    }
    // 单例接口
    static getInstance(param) {
        if(!this.instance) {
            this.instance = new Staff(param);
        }
        return this.instance;
    }
    // 完成工作
    doneWork() {
        console.log("staff完成工作")
    }
}
//这个子类继承这个父类
/**
 * 服务员类，继承自职员
 */
class Waiter extends Staff {
    constructor ({name = '', wages = 0} = {}) {
        super(name, wages); // 使用super代替call(this) 
    }                                     // 创造了一个这个子类的this 不然使用的是父类的this
    // 服务员完成工作
    waiterWork(order) {
        //如果参数是个数组，则记录客人点菜，如果参数不是数组则是上菜行为
        if(typeof order === 'array') {
            console.log("记录点菜")
        }
        else {
            console.log("进行上菜")
        }
        Waiter.prototype.doneWork();
    }
}
Waiter.getinstance()
xxx.getinstance()//两个创建出来的单例 是不同的


//动态给this设置属性名称
// list是一个数组对象
    constructor (list) {
        this[list[2].name] = list[2].name;
    }
```

## 19.判断数组对象

`[{xx},{xxx},{xxxx}]`这种形式为数组对象，但是如果你用`typeof`判断是不是数组就很尴尬了，因为无论如何都返回的类型时`object`，正确的做法可以是，判断长度`length`因为对象是没有这个属性的，而数组有。

```javascript
order.length !== undefined && typeof order !== "string" // 别忘了字符串也有长度属性
xxx instanceof Array // 这种方法更简单
```

## 20.工厂模式

[参考](https://segmentfault.com/a/1190000014196851#articleHeader0)

和1**7小节的单例**一样也属于设计模式的一种

工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类 。

工厂模式是用来创建对象的一种最常用的设计模式。我们**不暴露**创建对象的**具体**逻辑，而是将**将逻辑封装在一个**函数中，那么这个函数就可以被视为一个工厂。工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和抽象工厂。 

**我的理解**：有一个函数（工厂），你传入需求，返回一个需求的对象，本质上就两种模式`工厂`+`抽象工厂`

### 20.1简单工厂模式(常用)

在实际的项目中，我们常常需要根据用户的权限来渲染不同的页面，高级权限的用户所拥有的页面有些是无法被低级权限的用户所查看。所以我们可以在不同权限等级用户的构造函数中，保存该用户能够看到的页面。在根据权限实例化用户。代码如下： 

```javascript
let UserFactory = function (role) {
  // 角色不同 对应的构造函数不同
  function SuperAdmin() {
    this.name = "超级管理员",
    this.viewPage = ['首页', '通讯录', '发现页', '应用数据', '权限管理']
  }
  function Admin() {
    this.name = "管理员",
    this.viewPage = ['首页', '通讯录', '发现页', '应用数据']
  }
  function NormalUser() {
    this.name = '普通用户',
    this.viewPage = ['首页', '通讯录', '发现页']
  }
// 根据传入的role参数 选择构造函数
  switch (role) {
    case 'superAdmin':
      return new SuperAdmin();
      break;
    case 'admin':
      return new Admin();
      break;
    case 'user':
      return new NormalUser();
      break;
    default:
      throw new Error('参数错误, 可选参数:superAdmin、admin、user');
  }
}

//调用
let superAdmin = UserFactory('superAdmin');
let admin = UserFactory('admin') 
let normalUser = UserFactory('user')
```

==小结==：可以看到对于`UserFactory`这个工厂函数，我们可以传递不同`role`去创建我们想要的实例。

简单工厂的优点在于，你只需要一个正确的参数，就可以获取到你所需要的对象，而无需知道其创建的具体细节。

**但是**在函数内包含了所有对象的创建逻辑（构造函数）和判断逻辑的代码，每增加新的构造函数还需要修改判断逻辑代码。当我们的对象不是上面的3个而是30个或更多时，这个函数会成为一个庞大的超级函数，便得难以维护。所以，简单工厂**只能作用于**创建的**对象数量较少**，**对象的创建逻辑不复杂**时使用。 

### 20.2工厂方法模式

工厂方法模式的本意是**将实际创建对象的工作推迟到子类中**，这样核心类就变成了抽象类。但是在JavaScript中很难像传统面向对象那样去实现创建抽象类。所以在JavaScript中我们只需要参考它的核心思想即可。我们可以将工厂方法看作是一个**实例化对象**的工厂**类**。 （把上面的工厂函数变为工厂类）

---

在简单工厂模式中，我们每添加一个构造函数需要修改两处代码。

现在我们使用工厂方法模式改造上面的代码，刚才提到，工厂方法我们只把它看作是一个实例化对象的工厂，它只**做实例化对象**这一件事情！ 我们采用安全模式创建对象。 

```javascript
//安全模式创建的工厂方法函数
let UserFactory = function(role) {
  if(this instanceof UserFactory) {
    var s = new this[role]();
    return s;
  } else {
    return new UserFactory(role);
  }
}

//工厂方法函数的原型中设置所有对象的构造函数
// 实例化的时候就UserFactory.SuperAdmin 这一步实际上是在构造函数里面的
UserFactory.prototype = {
  SuperAdmin: function() {
    this.name = "超级管理员",
    this.viewPage = ['首页', '通讯录', '发现页', '应用数据', '权限管理']
  },
  Admin: function() {
    this.name = "管理员",
    this.viewPage = ['首页', '通讯录', '发现页', '应用数据']
  },
  NormalUser: function() {
    this.name = '普通用户',
    this.viewPage = ['首页', '通讯录', '发现页']
  }
}

//调用
let superAdmin = UserFactory('SuperAdmin');
let admin = UserFactory('Admin') 
let normalUser = UserFactory('NormalUser')
```

==解释==一下这段代码

```javascript
// 主要的这部分
let UserFactory = function(role) {
  if(this instanceof UserFactory) {
    var s = new this[role]();
    return s;
  } else {
    return new UserFactory(role);
  }
}
//调用
let superAdmin = UserFactory('SuperAdmin');
// 先分析一下实例的过程
调用工厂函数（构造函数）=>this指向全局(调用者是一个普通变量)
    =>进入return new UserFactory(role)这句
        =>上面这句 有点像递归 因为又调用了UserFactory构造函数
        	=>这次调用 因为已经new了 所以this是指向的一个UserFactory实例 
            	=>执行 var s = new this[role]() 返回一个用户
 // 那么安全模式作用在哪
 // 如果是普通的方法 每一次实例用户都要手动new 一个UserFactory，而安全模式省去了这一步
```

上面的这段代码就很好的解决了每添加一个构造函数就需要修改两处代码的问题，如果我们需要添加新的角色，只需要在`UserFactory.prototype`中添加。例如，我们需要添加一个`VipUser`: 

```javascript
UserFactory.prototype = {
  //....
  VipUser: function() {
    this.name = '付费用户',    
    this.viewPage = ['首页', '通讯录', '发现页', 'VIP页']
  }
}

//调用
let vipUser = UserFactory('VipUser');
```

### 20.3抽象工厂模式

```javascript
// 这个函数就是个继承extend函数
let AccountAbstractFactory = function(subType, superType) {
  //判断抽象工厂中是否有该抽象类
  if(typeof AccountAbstractFactory[superType] === 'function') {
    //缓存类
    function F() {};
    //继承父类属性和方法
    F.prototype = new AccountAbstractFactory[superType] ();
    //将子类的constructor指向子类
    subType.constructor = subType;
    //子类原型继承父类
    subType.prototype = new F();

  } else {
    throw new Error('抽象类不存在!')
  }
}
// 以一类为例
//微信用户抽象类
AccountAbstractFactory.WechatUser = function() {
  this.type = 'wechat';// 注意这里不是写在原型上的 而是增加了一个属性WechatUser()构造函数
}
AccountAbstractFactory.WechatUser.prototype = {// 给WechatUser增加一个方法
  getName: function() {// 这就是抽象方法 如果没有覆写这个方法 就会报错
    return new Error('抽象方法不能调用');
  }
}
//普通微信用户子类
function UserOfWechat(name) {
  this.name = name;
  this.viewPage = ['首页', '通讯录', '发现页']
}
//抽象工厂实现WechatUser类的继承
AccountAbstractFactory(UserOfWechat, 'WechatUser');
//子类中重写抽象方法
UserOfWechat.prototype.getName = function() {
  return this.name;
}
//实例化微信用户
let wechatUserA = new UserOfWechat('微信小李');
console.log(wechatUserA.getName(), wechatUserA.type); //微信小李 wechat
let wechatUserB = new UserOfWechat('微信小王');
console.log(wechatUserB.getName(), wechatUserB.type); //微信小王 wechat
```

==小结==：**首先**构造了一个继承函数，**然后**在继承函数的原型上，创造了一个抽象类`WechatUser`的构造函数(抽象类的方法需要覆写)，**随后**将实例对象的任务**交给了**这个抽象类，对于接下来的操作都是基于这个抽象类的，比如上面代码，想创建一个普通微信用户子类，只需要创建好`UserOfWechat`后从`WechatUser`继承，然后覆写抽象类(**为什么覆写**，因为每个子类需要的这个抽象方法功能不同)，最后实例的时候直接`new UserOfWechat`

==有什么用呢==：如果用户结构是这样的

```javascript
普通   vip    普通   vip    普通   vip    
 \      /     \      /      \      /
  \    /       \    /        \    /
    QQ         wechat          weibo
     \            |             /
       \          |            /
         \        |          /
               一个用户
               
// 如果使用普通的工厂模式
// 其实也可以 就是继承关系没有这么明确
// 普通工厂模式 要想加一个vip用户 就得在原型上 增加一个构造函数 
// 所以 构造出来的vip用户 只属于vip类 而不是像抽象工厂一样 直属与vip类 继承与qq (最后其实就是属于qq类)
```



### 20.4使用ES6的方式改写

```javascript
// 简单工厂模式
//User类
class User {
  //构造器
  constructor(opt) {
    this.name = opt.name;
    this.viewPage = opt.viewPage;
  }
  //静态方法
  static getInstance(role) {
    switch (role) {
      case 'superAdmin':
        return new User({ name: '超级管理员', viewPage: ['首页', '通讯录', '发现页', '应用数据', '权限管理'] });
        break;
	// .....为了简短 省去一部分
      default:
        throw new Error('参数错误, 可选参数:superAdmin、admin、user')
    }
  }
}
//调用
let superAdmin = User.getInstance('superAdmin');
```

虽然ES6也没有实现`abstract`，但是我们可以使用`new.target`来模拟出抽象类。

`new.target`指向直接被`new`执行的构造函数，

我们对`new.target`进行判断，如果指向了该类则抛出错误来使得该类成为抽象类。下面我们来改造代码。 

```javascript
class User {
  constructor(name = '', viewPage = []) {
    if(new.target === User) {
      throw new Error('抽象类不能实例化!');
    }
    this.name = name;
    this.viewPage = viewPage;
  }
}

class UserFactory extends User {
  constructor(name, viewPage) {
    super(name, viewPage)
  }
  create(role) {
    switch (role) {
      case 'superAdmin': 
        return new UserFactory( '超级管理员', ['首页', '通讯录', '发现页', '应用数据', '权限管理'] );
        break;
//.........................
      default:
        throw new Error('参数错误, 可选参数:superAdmin、admin、user')
    }
  }
}

let userFactory = new UserFactory();
let superAdmin = userFactory.create('superAdmin');
```

抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建。我们同样使用`new.target`语法来模拟抽象类，并通过继承的方式创建出`UserOfWechat`, `UserOfQq`, `UserOfWeibo`这一系列子类类簇。使用`getAbstractUserFactor`来返回指定的类簇。 

```javascript
class User {
  constructor(type) {
    if (new.target === User) {
      throw new Error('抽象类不能实例化!')
    }
    this.type = type;
  }
}

class UserOfWechat extends User {
  constructor(name) {
    super('wechat');
    this.name = name;
    this.viewPage = ['首页', '通讯录', '发现页']
  }
}
//....
function getAbstractUserFactory(type) {
  switch (type) {
    case 'wechat':
      return UserOfWechat;
      break;
//..................
    default:
      throw new Error('参数错误, 可选参数:superAdmin、admin、user')
  }
}
let WechatUserClass = getAbstractUserFactory('wechat');// 返回了一个没有new的微信类
let wechatUser = new WechatUserClass('微信小李');// 输入参数 想创建什么微信类
```

## 21.命令模式

[参考](https://www.jianshu.com/p/500219498569)

因此命令模式把请求封装成command对象，这个对象可以在程序中四处传递 ，传递信息。

使得请求**发送者**和请求**接收者**能够**消除**彼此的**耦合**关系 

```javascript
<body> 
    <button></button> 
	<button></button> 
	<button></button> 
	<button></button> 
	<button></button> 
</body>
// 我们想要给这些按钮绑定事件，相当于JS和html分别作为 发送者和请求者
// 假设我们并不知道 应该在哪个按钮绑定什么事件 都是临时决定

// 设置命令函数 （哪个按钮，事件函数）
var setCommand = function (button,func) { 
    button.onclick = function () { 
        func() 
    } 
} 
// 菜单的所有方法
var MenuBar = { 
    refresh : function () { 
        console.log('refresh menu pages') 
    } 
} 
// 刷新菜单的方法
var RefreshMenuBarCommand = function (receiver) { 
    //这里的receiver没体现出用途
    // 加入我们有个movecommand， 我们想向一个方向前进，那么receiver可以是left right..
    return function () { 
        receiver.refresh() 
    } 
} 

var RefreshMenuBarCommand = RefreshMenuBarCommand(MenuBar) setCommand(button1,RefreshMenuBarCommand)
// 撤销很简单
就是再定义一个方法 把初始状态恢复
// 宏命令 //一口气添加很多命令 然后再一起执行
var closeDoorCommand = { 
    execute:function () { 
        console.log('closedoor') 
    } 
}; 
var openPcCommand = { 
    execute : function () { 
        console.log('open PC') 
    } 
}; 
var openQQCommand = { 
    execute : function () { 
        console.log('login qq') 
    } 
}; 
var MacroCommand = function () { 
    return { 
            commandsList : [],

            add: function (command) { // 把很多命令存到列表里
                this.commandsList.push(command) 
            },

            execute:function () { // 调用execute方法就依次执行
                let command = this.commandsList;
                for(var i = 0; command[i]; i++){ 
                    command[i].execute();
                } 
            } 
        } 
} 
var macroCommand = MacroCommand(); 
macroCommand.add(closeDoorCommand) 
macroCommand.add(openPcCommand) 
macroCommand.add(openQQCommand) 
macroCommand.execute()
```

## 22.责任链模式

[参考](https://www.cnblogs.com/editor/p/5679552.html)

它是一种**链式结构**，每个节点都有可能两种操作，**要么**处理该请求停止该请求操作 **要么**把请求转发到下一个节点，让下一个节点来处理请求 。

```javascript
// 处理对象构造函数 
// 给不同的节点使用 让节点创造自己的处理对象
function Handler() {
    this.next = null;
    this.setNext = function(_handler) {
        this.next = _handler;
    };
    this.handleRequest = function(money) {
    }
};

//采购部
function CGBHandler = function() {}
CGBHandler.prototype = new Handler();
// 覆写handleRequest
CGBHandler.prototype.handleRequest = function(money) {
     //处理权限最多10000
    if (money < 10000){
        console.log('同意');
    } else {
        console.log('金额太大，只能处理一万以内的采购');
        if (this.next) {// setnext在末尾 调用的适合有设置
            this.next.handleRequest(money);
        }
    }
};

//总经理
function ZJLHandler = function() {}
ZJLHandler .prototype = new Handler();
ZJLHandler .prototype.handleRequest = function(money) {
     //处理权限最多100000
    if (money < 100000){
        console.log('10万以内的同意');
    } else {
        console.log('金额太大，只能处理十万以内的采购');
        if (this.next) {
            this.next.handleRequest(money);
        }
    }
};

//董事长
function DSZHandler = function() {}
DSZHandler .prototype = new Handler();
DSZHandler .prototype.handleRequest = function(money) {
     //处理权限至少100000
    if (money >= 100000){
        console.log('10万以上的我来处理');
        //处理其他逻辑
    } 
};

//调用
function Client() {
    var cgb = new CGBHandler();
    var zjl = new ZJLHandler();
    var dsz = new DSZHandler();
    cgb.setNext(zjl);
    zjl.setNext(dsz);
    
    cgb.handleRequest(800000);
}
```

## 23.适配器模式

```javascript
function interfaceMethod(str1, str2, str3) {//本来需要三个单独的字符串做输入
     //...
 }
 var clientObject = {// 但是输入是一个对象
     string1: 'foo',
     string2: 'bar',
     string3: 'baz'
 };
 // 所以用一个适配器包裹 使得能够适配
 function clientToInterfaceAdapter(o) {
     interfaceMethod(o.string1, o.string2, o.string3); 
}
clientToInterfaceAdapter(clientObject);
```

==如果==更新了代码后，发现需要更改另一处的代码，为了避免更改，可以使用适配器，也就是在外面包裹一层，使得输入符合新的代码

## 24.桥接模式

[参考1](https://www.cnblogs.com/TomXu/archive/2012/04/19/2437321.html)

`抽象`与`具体实现`分离。

```javascript
// 以forEach为例 
var forEach = function (arr, fn) { // 这个forEach函数就是一个  抽象
    for (var i = 0; i < arr.length; i++) {
        var val = arr[i];
        if (fn.call(this, i, val, arr)) {
            return false;
        }
    }
}
var arr = [1, 2, 3, 4];
forEach(arr, function (i, v) { // 这里的function就是具体实现
    arr[i] = v * 2;
})
// 所以我们不需要给各种forEach方法单独设置，我们就设置一个抽象的
```

## 25.观察者模式

```javascript
var pubsub = {};   // 定义发布者

(function (q) {

    var list = [],  //回调函数存放的数组，也就是记录有多少人订阅了我们东西
        subUid = -1;

    // 发布消息,遍历订阅者
    q.publish = function (type, content) {
        // type 为文章类型，content为文章内容
        
        // 如果没有人订阅，直接返回
        if (!list[type]) {

            return false;
        }

        setTimeout(function () {
            var subscribers = list[type],
                len = subscribers.length;

            while (len--) {
                // 将内容注入到订阅者那里
                subscribers[len].func(type, content);
            }
        }, 0);

        return true;

    };
    //订阅方法，由订阅者来执行
    q.subscribe = function (type, func) {
        // 如果之前没有订阅过
        if (!list[type]) {
            list[type] = [];
        }

        // token相当于订阅者的id，这样的话如果退订，我们就可以针对它来知道是谁退订了。
        var token = (++subUid).toString();
        // 每订阅一个，就把它存入到我们的数组中去
        list[type].push({
            token: token,
            func: func
        });
        return token;
    };
    //退订方法
    q.unsubscribe = function (token) {
        for (var m in list) {
            if (list[m]) {
                for (var i = 0, j = list[m].length; i < j; i++) {
                    if (list[m][i].token === token) {
                        list[m].splice(i, 1);
                        return token;
                    }
                }
            }
        }
        return false;
    };

} (pubsub));

//将订阅赋值给一个变量，以便退订
var girlA = pubsub.subscribe('js类的文章', function (type, content) {
    console.log('girlA订阅的'+type + ": 内容内容为：" + content);
});
var girlB = pubsub.subscribe('js类的文章', function (type, content) {
    console.log('girlB订阅的'+type + ": 内容内容为：" + content);
});
var girlC = pubsub.subscribe('js类的文章', function (type, content) {
    console.log('girlC订阅的'+type + ": 内容内容为：" + content);
});

//发布通知
pubsub.publish('js类的文章', '关于js的内容');  
// 输出：
// girlC订阅的js类的文章: 内容内容为：关于js的内容
// test3.html:78 girlB订阅的js类的文章: 内容内容为：关于js的内容
// test3.html:75 girlA订阅的js类的文章: 内容内容为：关于js的内容


//girlA退订了关于js类的文章 
setTimeout(function () {
    pubsub.unsubscribe(girlA);
}, 0);

//再发布一次，验证一下是否还能够输出信息
pubsub.publish('js类的文章', "关于js的第二篇文章");
// 输出：
// girlB订阅的js类的文章: 内容内容为：关于js的第二篇文章
// girlC订阅的js类的文章: 内容内容为：关于js的第二篇文章
```

## 26.EventBus

观察者：一个发，其他都被动接收

事件总线：一个发，其他的主动接收

```javascript
(function(){
    //创建EventBus对象
    EventBus = function () {
        console.log("maps init...");
    };
    //准备数组容器
    var objBus = [],arrbus = [];
    //添加方法
    EventBus.prototype = {
        obj : {
            set : function(key,action){
                if(key && action){
                    var map = {};
                    map.k = key;
                    map.v = action;
                    //如果存在，则删除之前添加的事件
                    for(var i = 0,busLength = objBus.length;i < busLength;i ++){
                        var tempMap = objBus[i];
                        if(tempMap.k == key){
                            objBus.splice(i,1);
                        }
                    }
                    objBus.push(map);
                }
            },
            get : function(key){
                if(key){
                    for(var i = 0,busLength = objBus.length;i < busLength;i ++){
                        var map = objBus[i];
                        if(map.k == key){
                            return map.v();
                        }
                    }
                }
            }
        },
        arr : {
            push : function (key,action) {
                if(key && action){
                    var map = {};
                    map.k = key;
                    map.v = action;
                    arrbus.push(map);
                }
            },
            pop : function (key) {
                if(key){
                    for(var i = 0,busLength = arrbus.length;i < busLength;i ++){
                        var map = arrbus[i];
                        if(map.k == key){
                            map.v();
                        }
                    }
                }
            }
        }
    }
})();
function testObj(){
        eventBus.obj.set('event1',function(){
            console.log('event1');
        });
        eventBus.obj.set('event1',function(){
            console.log('event2');
        });
        eventBus.obj.set('event3',function(){
            console.log('event3');
        });

        eventBus.obj.get('event1');
    }

    //测试obj
    testObj();
event2

function testArr() {
        eventBus.arr.push('event1',function(){
            console.log('event1');
        });
        eventBus.arr.push('event1',function(){
            console.log('event2');
        });
        eventBus.arr.push('event3',function(){
            console.log('event3');
        });

        eventBus.arr.pop('event1');
    }

    //测试arr
    testArr();

event1
event2
```

